#《Android开发艺术探索》读书笔记
#第四章 View的工作原理
##4.1 ViewRoot和DecorView
   ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程都是通过ViewRoot完成的，在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会建立ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联<br>
	   View的绘制流程就是从ViewRoot的performTraversals方法开始的，经过measure，layout和draw三个过程才能最终将一个View绘制出来，分别对应的几个方法是onMeasure(),onLayout(),onDraw()<br>
	   具体的调用过程是：performTraversals会依次调用performMeasure，performLayout，performDraw三个方法，分别完成顶级View的measure，layout，draw三个流程，在performMeasure中会调用measure方法，measure方法又会调用onMeasure方法，在onMeasure方法中会对所有的子元素进行measure过程，这时候measure流程就从父元素传到子元素了，完成了一次measure过程，接着子元素会重复父元素的measure过程，如此反复就完成了整个View树的遍历，performLayout和performDraw类似，不同的是，performDraw中的传递过程是在draw方法中通过dispDraw来实现的。<br>
	   (1)measure过程决定了View的宽/高，完成后可以通过getMeasureWidth和getMeasureHeight方法获取View测量后的宽/高，除特殊情况外，一般都是View的最终宽/高。<br>
	   (2)Layout过程决定了View四个顶点的坐标和View的实际宽/高，可以通过getWidth和getHeight取到View的最终宽/高。<br>
	   (3)Draw过程决定了View的显示，只有Draw方法完成后View的内能呈现在屏幕上<br>
	   DecorView作为顶级View，一般它的内部会包含一个竖直方向的LinearLayout，在这个LinearLayout有上下两个部分，一个是标题栏，一个是内容栏(我们通过setContentView设置的View就是加到内容栏进去的)，内容栏的id是content，这就解释了Android中设置界面布局的方法为什么是setContentView而不是setView，因为我们的布局添加到了id为content的FrameLayout中，那么怎么得到content呢=>` ViewGroup content = findViewById(R.android.id.content)`，怎么得到View呢=>`content.getChildAt(0) `。<br>
##4.2 理解MeasureSpec
1. 理解MeasureSpec有利于更好地去理解View的测量过程。<br>
	    MeasureSpec在很大程度上决定了一个View的尺寸规格，因为这个规格还受父容器的影响，因为父容器影响View的MeasureSpec的创建过程。<br>
	    测量过程中系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec，再根据这个MeasureSpec来测量出View的宽/高。这里的宽高是测量宽高，不一定的最终的宽高。<br>
	    MeasureSpec代表一个32位int值，高2位是SpecMode，低30位是SpecSize，SpecMode是测量模式，SpecSize是在模仿模式下的规格大小；<br>
	    (1)SpecMode有3类：<br>
	     ①UNSPECIFIED=>父容器不对View有任何限制，要多大就给多大，这种情况一般用于系统内部，表示一种测量的状态。<br>
	     ②EXACTLY=>父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值，他对应于LayoutParams中的match_parent和具体的数值这两种模式；<br>
	     ③AT_MOST=>父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么要看View的具体实现，对应于LayoutParams中的wrap_content；<br>
	   2.MeasureSpec和LayoutParams的对应关系<br>
	     系统内部都是通过MeasureSpec进行View的测量，正常情况下我们使用View指定MeasureSpec，还是可以给View设置LayoutParams，在View测量时，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽/高。<br>
	     注意:<br>①MeasureSpec不是仅仅由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步决定View的宽/高；<br>②对于顶级View(即DecorView)，MeasureSpec的过程和普通的View的这个过程不太相同。DecorView的MeasureSpec由窗口的尺寸和自身的LayoutParams共同决定；而普通的View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams共同决定，MeasureSpec一旦确定后，onMeasure中就可以确定View的宽/高。<br>
##4.3 View的工作流程
三大流程，就是测量，布局和绘制。<br>
	    1.measure过程<br>
	      (1)View的measure过程<br>
		  View的measure过程由其measure方法来完成，measure方法是个final方法，子类不能重写，在View的measure方法中会调onMeasure方法，分析View的onMeasure方法<br>
	      (2)ViewGroup的measure过程<br>
		   对ViewGroup来说，除了要完成自己的measure过程外，还要遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个过程。不同于View，ViewGroup是一个抽象类，没有重写View的onMeasure方法，但是提供了一个measureChildren的方法
	    2.layout过程<br>
	    3.draw过程<br>
	       (1)绘制背景=>background.draw(canvas)<br>
                (2)绘制自己onDraw<br>
	       (3)绘制children(dispatchDraw)<br>
	       (4)绘制装饰(onDrawScrollBars)<br>
##4.4  自定义View
  1. 分类<br>
	      ①继承View重写onDraw方法<br>
	          这种方法主要用于实现一些不规则的效果<br>
	      ②继承ViewGroup派生特殊的Layout<br>
		 主要用于实现自定义的布局<br>
	      ③继承特定的View比如TextView<br>
		 比较常见，用于实现扩展常用View的功能，实现简单<br>
	      ④继承特定的ViewGroup比如LinearLayout<br>
		 常见，当某种效果看起来像是几种View组合在一起的时候，可以用这种方法<br>
2. 自定义View须知<br>
	      ①让View支持wrap_content<br>
	      ②如果有必要，让你的View支持padding<br>
	      ③尽量不要在View中使用Handler，没有必要<br>
	          因为View本身就提供了post系列的方法，完全可以代替Handler的作用<br>
	      ④View中如果有线程或者动画，要及时停止<br>
	      ⑤View带有滑动嵌套情形时要处理好滑动冲突<br>
 3. 例子<br>
4. 自定义View的思想<br>