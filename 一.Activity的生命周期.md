##第一章 Activity的生命周期
###1.1 Activity的生命周期全面分析<br>
   1.1.1 典型情况下的生命周期分析<br>
         (1)onCreate()<br> 表示Activity正在被创建，做初始化的工作<br>
	     (2)onRestart()<br>当Activity由不可见状态变为可见状态时会被调用<br>
         (3)onStart()<br>表示正在被启动，此时Activity已经可见，不过还是不能和用户交互，理解为已经显示出来了但是我们还没看到<br>
         (4)onResume()<br>表示Activity已经可见了，并且已出现在前台并开始活动，注意它和onStart的区别，onResume()和onStart()都表示Activity可见，但是onStart()的时候Activity还在后台，onResume()的时候Activity就显示到前台了<br>
         (5)onPause()<br>表示Activity正在停止<br>
         (6)onStop()<br>表示Activity即将停止，可以做些回收工作，不能太耗时<br>
         (7)onDestory()<br>表示Activity即将被销毁，可以做些回收工作和资源释放<br>
  几种情况：<br>
         (1)一个特定的Activity，第一次启动，回调如下：onCreate=>onStrat=>onResume<br>
         (2)当用户打开新的Activity或者切换到桌面时，回调如下：onPause=>onStop,注意，如果当新的Activity采用了透明主题，那么当前Activity不会回调onStop<br>
         (3)当用户再次回到原Activity时，回调如下：onRestart=>onStart=>onResume<br>
         (4)当用户按下Back键，回调如下：onPause=>onStop=>onDestory<br>
         (5)当Activity被系统回收后再次打开，生命周期回调和(1)同，但注意只是方法回调相同，不是所有的过程一样<br>
         (6)配对情况：<br>
         ①从整个生命周期来说，onCreate和onDestory配对，分别标识Activity的创建和销毁，只可能有一次调用；<br>
         ②从是否可见来说，onStart和onStop配对，可能被调用多次<br>
         ③从Activity是否在前台来说，onResume和onPause配对，可能被调用多次<br>
  两个问题：<br>
         (1)onStart和onResume，onPause和onStop好像差不多，有什么实质性的不同吗<br>
         (2)将设A跳转到B,那么A的onPause和B的onResume哪个会先执行呢？<br>
  1.1.2 异常情况下的生命周期分析<br>
        Activity除了受用户操作所导致的正常的生命周期方法调度，还有一些异常情况，比如当资源相关的系统配置发生改变以及系统内存不足时，Activity就可能被杀死<br>
        (1)case one:资源相关的系统配置发生改变导致Activity被杀死并重建<br>
        当系统配置发生变化后，Activity会被销毁，其onPause，onStop，onDestory均会被调用，同时因为Activity是在异常情况下终止的，系统会调用onSaveInstanceState()来保存当前Activity的状态。这个方法的调用是在onStop之前，可能是在onPause之前或者之后调用。并将所保存的Bundle对象作为参数传给onRestoreInstanceState和onCreate方法，所以我们可以通过onRestoreInstanceState和onCreate方法判断Activity是否重建了，如果重建了就取出之前保存的数据并恢复，从时序上，onRestoreInstanceState的调用时机在onStart之后。<br>
        (2)case two:资源内存不足导致低优先级的Activity被杀死<br> 
        Activity按照优先级分有以下3种：<br>
        ①前台Activity=>正在和用户交互的Activity，优先级最高；<br>
        ②可见但是非前台Activity=>比如弹出了个对话框，导致Activity无法和用户交互；<br>
        ③后台Activity=>已经被暂停的Activity，比如执行了onStop，优先级最低<br>
        当系统配置改变时，能不能不让Activity重建呢？=>可以给Activity指定configChanges属性添加orientation这个值<br>
	    ` android:configChanges="orientation"`<br>
        如果想指定多个值，用'|'连接<br>
        `android:configChanges="orientation|keyboardHidden"`<br>
        注意两个特殊的属性值，screenSize和smallestScreenSize，和编译项目有关，就是说如果你的最低和目标版本有一个是超过了Api13的话，就要加上screenSize来防止Activity重建了<br>
        阻止了Activity的重建，也没有调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，取而代之的是系统调用了Activity的onConfigurationChanged方法<br>
###1.2 Activity的启动模式
   1.2.1 Activity的LaunchMode<br>
       (1)standard<br>
         如果A启动了B，那么B就会进入到A所在的栈中，一个小Bug==>当你用ApplicationContext去启动标准模式的Activity时会报错，原因是标准模式的Activity会进入启动它的Activity的任务栈中，但是非Activity的Context没有所谓的任务栈，就有问题了，解决的方法是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候会给它创建一个新的任务栈，也就是singleTask模式了。<br>
	   (2)singleTop<br>
         栈顶复用模式，如果想要启动的Activity已经在栈顶了，就不会重建Activity了，同时他的onNewIntent方法会被回调，注意：这个Activity的onCreate和onStart不会被系统调用，如果新Activity的实例已经存在但是不在栈顶，还是会被重建。
       (3)singleTask<br>
         栈内复用模式，是一种单实例模式，系统也会调用onNewIntent方法，有clearTop效果，比如当前是ADBC(A在栈底)，再调用这种模式的D的话，任务栈就变成了AD<br>
       (4)singleInstance<br>
         单实例模式，是一种加强的singleTask<br>
       注意:①在singleTask，Activity所需的任务栈很重要，那么，什么是它所需要的任务栈呢？<br>一个叫TaskAffinity的参数，可以指定任务栈的名字，默认情况下，所有Activity所需的任务栈的名字是应用的包名，这个属性要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。<br>②任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity处于暂停状态<br>
       除了在Manifest中给activity标签设置launchMode属性外就是给intent加Flags了，调intent.addFlags(),后者的优先级较高，另外就在限定范围不同，第一种无法直接为Activity设定FLAG_ACTIVITY_CLEAR_TOP标识，第二种无法为Activity指定singleInstance模式<br>
   1.2.2 Activity的Flags<br>
            (1)FLAG_ACTIVITY_NEW_TASK=>singleTask<br>
            (2)FLAG_ACTIVITY_SINGLE_TOP=>singleTop<br>
	   (3)FLAG_ACTIVITY_CLEAR_TOP=>一般和FLAG_ACTIVITY_NEW_TASK配合使用，如果被启动的Activity实例已经存在，系统会调用它的onNewIntent方法。<br>
	   (4)FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS<br>具有这个标记的Activity不会出现在历史Activity的列表中，和在Manifest中指定Activity的属性android:excludeFromRecents="true"是等效的</br>
   1.3 IntentFilter的匹配规则<br> 
       两种启动Activity的方式(1)显示调用；(2)隐式调用；<br>
       隐式调用需要Intent能匹配目标组件的IntentFilter中的过滤信息，比如action，category，data，一个Activity中可以有多个intentfilter<br>
       各种属性的匹配规则<br>
       (1)action的匹配规则<br>
	   如果没有指定，那么就会匹配失败，而且区分大小写<br>         
       (2)category的匹配规则<br>
	   和action的匹配规则不同<br>
       (3)data的匹配规则<br>
	   和action的匹配规则类似,
            (A)data的结构和语法，data由两部分组成mimeType和URL，mimeType是指媒体类型，比如image/jpeg,audio/mpeg4-generic和video/*等，而URL包含的就比较多了<br>
           ①Scheme=>URL的模式，比如http，file，content等，如果没有指定，其他参数会无效<br>
           ②Host=>如果没有指定，其他参数会无效<br>
           ③Port=>只有前面两个参数设置好了这个参数才是有意义的<br>
           ④Path，pathPattern和pathPrefix=>表述路径信息<br>
  	  (B)data的匹配规则<br>
      tip:Intent-Filter的匹配规则对于Service和BroadcastReceiver也是一样,不过系统对于Service的使用还是建议用显示调用<br>
  
          