#《Android开发艺术探索》读书笔记
#第十一章 Android的线程和线程池
	
(1)除了Thread外，在Android中可以扮演线程角色的还有很多，比如AsyncTask和IntentService，同时HandlerThread也是一种特殊的线程。AsyncTask底层用到了线程池，IntentService和HandlerThread底层直接用了线程。<br>
	不同形态的线程有不同的特性和使用场景。<br>
	AsyncTask封装了线程池和Handler，主要是为了方便开发者在子线程中去更新UI。<br>
	HandlerThread是一种具有消息循环的线程，在它的内部可以用Handler。<br>
	IntentService是一个服务，系统对他进行了封装使其可以更方便执行后台任务，内部采用了HandlerThread来执行任务，任务执行完后IntentService会自动退出。从任务执行的角度看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，他不容易被系统杀死并可以尽量保证任务的执行，而如果仅仅是个后台线程的话，因为此时线程中没有活动的四大组件，那么这个进程的优先级会变得很低，很容易被系统杀死，这就是IntentService的优点；<br>
	(2)线程池的引入<br>
	频繁创建和销毁线程会有很大的开销，所以采用线程池，一个线程池中会缓存一定数量的线程，避免频繁创建和销毁线程带来的系统开销。Android中的线程池来源于java，主要通过Executor来派生特定类型的线程池，不同种类的线程池有不同的特性。<br>
##11.1 主线程和子线程
	
主线程是指进程拥有的线程，在java中默认情况下一个进程只有一个线程，这个线程就是主线程，作用是运行四大组件以及处理他们和用户的交互。<br>
	子线程也叫工作线程，作用是执行耗时的任务，Android3.0开始系统要求网络访问必须在子线程中进行，这就是为了避免ANR；<br>
##11.2 Android中的线程形态
	
除了Thread以外，还包含AsyncTask，HandlerThread以及IntentService，后三者的底层实现也是线程。为了简化在子线程中访问UI的过程，系统提供了AsyncTask，经过几次修改，导致了对于不同的API版本AsyncTask有不同的实现；<br>
11.2.1 AsyncTask<br>
	1.是轻量级的异步任务类，但是不适用于执行特别耗时的后台任务，特别耗时的建议用线程池；<br>
	AsyncTask是一个抽象的泛型类，提供了Params，Progress和Result三个泛型参数，Params表示参数的类型，Progress表示后台执行任务的进度，而Result表示后台执行任务返回的结果的类型，不需要就用Void代替，四个核心方法：<br>
	(1)onPreExecute(),在主线程执行，在异步任务执行前会被调用，一般做一些准备工作；<br>
	(2)doInBackground(Params...params)，在线程池中执行，用于执行异步任务，在这个方法中可以通过publishProgress方法来更新任务的进度，publishProgress方法会调用onProgressUpdate方法，另外该方法需要返回计算结果给onPostExecute方法；<br>
	(3)onProgressUpdate(Progress result)，在主线程执行，当后台任务的执行进度发生改变时该方法会被调用；<br>
	(4)onPostExecute(Result result)，在主线程中执行，在异步任务完成后该方法会被调用，result参数是后台任务的返回值，即doInBackground的返回值；<br>
	除了这四个方法外，还提供了onCancelled方法，同样在主线程中执行，异步任务被取消时，这个方法会被调用，这个时候onPostExecute就不会被调用；<br>
	2.在具体使用中的一些限制<br>
	(1)AsyncTask的类必须在主线程中被加载，意味着第一次访问AsyncTask必须发生在主线程，当然这个过程在Android4.1及以上的版本中已经被系统自动完成，在5.0的源码中，查看ActivityThread的main方法，会调用AsyncTask的init方法，这就满足了AsyncTask的类必须在主线程中进行加载这个条件了；<br>
	(2)AsyncTask的对象必须在主线程中创建；<br>
	(3)execute方法必须在主线程中调用；<br>
	(4)不要在程序中直接调用那四个方法；<br>
	(5)一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报异常；<br>
	(6)在Android1.6之前，AsyncTask是串行执行的，1.6时开始采用线程池处理并行任务，但是3.0开始，为了避免AsyncTask带来的并发错误，AsyncTask又采用了一个线程来串行执行任务，尽管如此，在3.0之后的版本中，仍然可以通过executeOnExecutor方法来并行执行任务；<br>
11.2.2 AsyncTask的工作原理<br>
	从execute方法开始分析，它又调用了executeOnExecutor方法；<br>
	` public final AsyncTask<Params, Progress, Result> execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);
    }`
sDefaultExecutor实际上是一个串行的线程池
	
11.2.3 HandlerThread<br>
	它继承了Thread，是一种可以使用Handler的Thread，实现较简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()开启消息循环。<br>
	和普通的Thread比较。<br>
11.2.4 IntentService<br>
	是一个抽象类，它封装了HandlerThread和Handler。<br>
##11.3 Android中的线程池
	
线程池的优点：<br>
	(1)重用线程池中的线程，避免因为线程的创建和销毁带来的性能开销；<br>
	(2)有效控制线程池的最大并发数；<br>
	(3)能对线程进行简单的管理，并提供定时执行和指定间隔循环执行等功能。<br>
	 Android中的线程池的概念来源于java中的Executor，Executor是一个接口，真正地线程池的实现是ThreadPoolExecutor。他提供了一系列的参数来配置线程池，通过不同的参数创建不同的线程池，按功能分，Android的线程池分为4种，可以通过Executor提供的工厂方法得到。<br>
11.3.1 ThreadPoolExecutor
	他是线程池的真正实现，他的构造方法提供了一系列参数来配置线程池，参数如下：<br>
	(1)corePoolSize<br>
	线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使他们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过这个时长后，核心线程就会被终止。<br>
	(2)maximumPoolSize<br>
	线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后序的新任务会被阻塞。<br>
	(3)keepAliveTime<br>
	非核心线程闲置时的超时时长，超过了这个时长，非核心线程就被回收，当ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程。<br>
	(4)unit<br>
	用于指定keepAliveTime参数的时间单位，是一个枚举。<br>
	(5)workQueue<br>
	线程池中的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中.<br>
	(6)threadFactory<br>
	线程工厂，为线程池提供创建新线程的功能，ThreadFactory是个接口，只有一个方法：Thread newThread(Runnable r)。<br> 
	ThreadPoolExecutor执行任务时遵循以下规则：<br> 
	(1)如果线程池中的线程数量未达到核心线程额数量，那么会直接启动一个核心线程来执行任务；<br> 
	(2)如果线程池中的线程数量已经达到或者超过核心线程额数量，那么任务会被插入到任务队列中排队等待执行；<br>
	(3)如果在(2)中无法将任务插入到任务队列中，这往往是由于任务队列已满，这时如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务；<br> 
	(4)如果(3)中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务；<br> 
	看下AsyncTask中的参数配置:<br> 
	①核心线程数==>cpu核心数+1；<br> 
	②线程池的最大线程数==>cpu核心数的2倍+1；<br> 
	③核心线程无超时限制，非核心线程在闲置时的超时时间是1秒；<br> 
	④任务队列的容量是128；<br> 
11.3.2 线程池的分类<br> 
	1. FixedThreadPool<br> 
	通过Executor的newFixedThreadPool方法来创建，是一种线程数量固定的线程池，当线程处于空闲状态时，他们并不会回收，除非线程池被关闭了。由于FixedThreadPool只有核心线程并且这些核心线程不会被回收，意味着它能更快响应外界的请求。这里面只有核心线程并且这些核心线程没有超时机制，另外任务队列也是没有大小限制的。<br> 
	2.CachedThreadPool<br> 
	通过Executor的newCachedThreadPool来创建。是一种线程数量不定的线程池，他只有非核心线程，并且最大线程数为Integer.MAX_VALUE。相当于最大线程数可以任意大。
	3.ScheduledThreadPool<br>
	通过Executor的newScheduledThreadPool方法来创建，他的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心闲置时会被立即回收。这类线程池主要用于执行定时任务和具有定时周期的重复任务。<br> 
	4.SingleThreadExecutor<br> 
	通过Executor的newSingleThreadExecutor方法来创建，内部只有一个核心线程，确保所有任务都在同一个线程中按顺序执行。它的意义在于统一所有的外界任务到一个线程中，使得这些任务之间不需要处理线程同步的问题。