#《Android开发艺术探索》读书笔记
#第五章 理解RemoteViews
##5.1 RemoteViews的应用
	桌面小部件和通知栏应用，无法像一般Activity的View那样直接去更新，因为二者的界面运行在不同的进程中，准确来说是系统的SystemServer进程，为了跨进程更新界面，RemoteViews提供了一系列的set方法。<br>
	5.1.1 RemoteViews在通知栏上的应用<br>
		自定义通知栏的布局，通过RemoteViews来加载这个布局文件；<br>
		使用简单，但是如何去更新RemoteViews呢，无法直接访问里面的View，必须通过RemoteViews提供的一系列方法来更新View；<br>
	5.1.2 RemoteViews在桌面小部件上的应用<br>
		AppWidgetProvider是Android中提供的用于实现桌面小部件的类，本质是一个广播，继承自BroadcastReceiver；<br>
		使用步骤：<br>
		(1)定义小部件界面<br>
		    在res/layout/下新建一个xml文件，命名为widget.xml<br>
		(2)定义小部件配置信息<br>
		    在res/xml/下新建appwidget_provider_info.xml<br>
		(3)定义小部件的实现类<br>
		    这个类需要继承AppWidgetProvider<br>
		(4)在AndroidManifest.xml中声明小部件<br>
		    实质上是声明广播组件，所以需要注册<br>
	5.1.3 PendingIntent概述<br>
		1.PendingIntent和Intent的区别是？=>PendingIntent是一种处于pending状态的Intent，pending状态表示一种待定，等待，即将发生的意思，就是说接下来会有一个Intent将在某个特定的时刻发生。而Intent是立刻发生；<br>
		  PendingIntent的典型使用场景是给RemoteViews添加一个单击事件，因为RemoteViews运行在远程进程中，所以RemoteViews不同于普通的View，无法直接像View那样通过setOnClickListener方法来设置单击事件，必须通过PendingIntent，PendingIntent通过send和cancel方法来发送和取消特定的待定Intent。<br>
		2. PendingIntent支持3中待定意图：<br>
		(1)启动Activity=>getActivity()<br>
		getActivity(Context context,int requestCode,Intent intent,int flags)，获得一个PendingIntent，该待定意图发生时，效果相当于Context.startActivity(Intent)；<br>
		(2)启动Service=>getService()<br>
		getService(Context context,int requestCode,Intent intent,int flags)，获得一个PendingIntent，该待定意图发生时，效果相当于Context.startService(Intent)；<br>
		(3)发送广播=>getBroadcast()<br>
		getService(Context context,int requestCode,Intent intent,int flags)，获得一个PendingIntent，该待定意图发生时，效果相当于Context.startBroadcast(Intent)；<br>
		注意：<br>
		(1)第二个参数requestCode表示PendingIntent发送方的请求码，多数情况下设置为0即可，另外requestCode会影响到flag的效果；<br>
		先说PendingIntent的匹配规则，即在什么情况下两个PendingIntent是相同的。规则是如果两个PendingIntent的他们内部的Intent相同且requestCode也相同，那么这两个PendingIntent就是相同的，那么什么是Intent相同呢，如果两个Intent的ComponentName和intent-filter相同，那么这两个Intent是相同的。需要注意的是Extras不参与Intent匹配的过程。<br>
		(2)第四个参数flag，flag常见的类型有:<br>
		①FLAG_ONE_SHOT<br>
		当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel，如果后面还有相同的PendingIntent，那么他的send方法就会调用失败。对于通知栏消息来说，如果采用此标记位，那么同类的通知只能使用一次，后续的通知单击后将无法打开。<br>
		②FLAG_NO_CREATE<br>
		当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity，getService，getBroadcast方法会直接返回null，即获取PendingIntent失败，这个标记位很少见，无法单独使用，在日常开发中没什么意义；<br>
		③FLAG_CANCEL_CURRENT<br>
		如果描述的PendingIntent已经存在，那么他们都会被cancel，然后系统会创建一个新的PendingIntent，对于通知栏信息来说，那些被cancel的消息单击后将无法打开；<br>
		④FLAG_UPDATE_CURRENT<br>
		如果描述的PendingIntent已经存在，那么他们都会被更新，即他们的Intent中的Extras会被替换成最新的。<br>
                  结合通知栏消息去理解，manager.notify(1,notification),如果notify的第一个参数id是常量，那么多次调用notify只会弹出一个通知，后续的会把前面的全部替代，如果每次的id都不同，那么多次调用notify会弹出多个通知，如果notify方法的参数id是常量，那么不管PendingIntent是否匹配，后面的通知都会直接替换前面的通知
##5.2 RemoteViews的内部机制
	
##5.3 RemoteViews的意义
