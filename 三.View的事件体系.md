#《Android开发艺术探索》读书笔记
#第三章 View的事件体系
##3.1View的基础知识
3.1.1 什么是View<br>
    	View是Android中所有控件的基类<br>
3.1.2 View的位置参数<br>
	View的位置由它的四个顶点决定，分别对应于View的四个属性：top，left，right，buttom，注意这些坐标都是相对于View的父容器来说的，所以它是一种相对坐标，view的宽高和坐标的关系：<br>
	width=right-left;<br>
	height=buttom-top;<br>
	那这四个参数怎么获取到呢，getLeft()，其他几个类似<br>
	从3.0开始，View增加了额外的几个参数:x,y,translationX和translationY，x和y是View左上角的坐标，后两个是左上角相对于父容器的偏移量，也有对应的get/set方法，换算关系是：x=left+translationX;y=top+translationY<br>
3.1.3 MotionEvent和TouchSlop<br>
	1.MotionEvent，3种典型的事件类型<br>
	(1)ACTION_DOWN;<br>
	(2)ACTION_MOVE;<br>
	(3)ACTION_UP;<br>
	2.分析<br>
	(1)点击屏幕后离开松开,事件序列为DOWN=>UP;<br>
	(2)点击屏幕滑动一下再离开，事件序列为DOWN=>MOVE=>...=>MOVE=>UP;<br>
        通过MotionEvent不仅可以监听事件，还可以得到坐标，系统提供了两组方法：getX/getY和getRawX/getRawY，区别如下：<br>
	getX/getY得到的是相对于当前View左上角的x和y坐标；getRawX/getRawY返回的是相对于屏幕左上角的x和y坐标；<br>
	3.TouchSlop<br>
	是系统所能识别出的被认为是滑动的最小距离，也就是说当手指在屏幕上滑动的距离小于这个值的时候，系统不会认为你是在滑动，该值和设备有关<br>
	如何获取这个常量呢？=>ViewConfiguration.get(getContext()).getScaledTouchSlop();<br>
	意义何在？=>用这个常量来进行一些过滤，当滑动的距离小于这个值时，做相应的控制，获得更好的用户体验<br>
3.1.4 VelocityTracker,GestureDetector和Scroller<br>
	1.VelocityTracker<br>
	速度追踪，用于跟踪手指在滑动过程中的速度，包括水平和竖直方向上的速度。使用方法：<br>
	在View的onTouchEvent方法中追踪点击事件的速度：<br>
	2.GestureDetector<br>
	手势检测，检测用户的单击，滑动，长按，双击等行为，使用方法：<br>
	3.Scroller<br>
	弹性滑动对象<br>
	用它来实现有过渡效果的滑动

##3.2 View的滑动
3.2.1 使用scrollTo和scrollBy<br>
	scrollBy实际也调用了scrollTo方法
3.2.2 使用动画<br>
3.2.3 改变布局参数<br>
3.2.4 各种滑动方式的对比<br>
	(1)scrollTo/scrollBy:操作简单，适合对View内容的滑动<br>
	(2)动画:操作简单，主要适用于没有交互的View和实现复杂的动画效果<br>
	(3)改变布局参数：操作稍微复杂，适用于有交互的View<br>
##3.3 弹性滑动
3.3.1 使用Scroller<br>
3.3.2 通过动画<br>
3.3.3 使用延时策略<br>
##3.4 View的事件分发机制
3.4.1 点击事件的传递规则<br>
	3个重要的方法：<br>
	(1)dispatchTouchEvent(MotionEvent)<br>
	(2)onInterceptTouchEvent(MotionEvent)<br>
	(3)onTouchEvent(MotionEvent)<br>
	     在dispatchTouchEvent中调用<br>
	对于一个根ViewGroup，点击事件发生后，首先会传递给它，此时他的dispatchTouchEvent会被调用，①如果这个ViewGroup的onInterceptTouchEvent方法返回的是true就表示他要拦截这个事件，这个事件就交给ViewGroup处理，ViewGroup的onTouchEvent方法会被调用；②如果onInterceptTouchEvent方法返回的是false，这个事件就继续传给它的子元素，子元素的dispatchTouchEvent方法会被调用，如此反复<br>
	事件产生后的传递过程：Activity=>Window=>View
	一些结论：<br>
	(1)同一个事件序列是指从手指接触屏幕开始到离开屏幕结束，这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间有若干个move事件，最后以up事件结束<br>
	(2)正常情况下，一个事件序列只能被一个View拦截且消耗，特殊手段可以做到被多个View拦截和消耗；<br>
	(3)某个View一旦决定拦截，那么这一个事件序列都只能由它来处理，并且他的onInterceptTouchEvent不会再被调用；<br>
	(4)某个View一旦开始处理事件，如果它不消耗DOWN事件(onTouchEvent方法返回了false)，那么同一个序列的其他事件都不会再交给他来处理，并且事件将重新交由他的父元素去处理，即父元素的onTouchEvent方法会被调用<br>
	(5)<br>
	(6)ViewGroup默认不拦截任何事件,ViewGroup的onInterceptTouchEvent方法返回的是false<br>
	(7)View没有onInterceptTouchEvent方法，一旦有事件传给他，他的onTouchEvent方法就被调用<br>
	(8)View的onTouchEvent默认都会消耗事件(返回ture)，除非他是不可点击的(clickable和longClickable同时为false)。View的longClickable属性默认是false，clickable属性要分情况，Button的clickable属性就是ture，TextView就是false；<br>
	(9)View的enable属性不影响onTouchEvent的默认返回值，即使一个View是disable的，只要他的clickable或者longClickable有一个是true，那么他的onTouchEvent就返回true；<br>
	(10)onClick会发生的前提是当前的View是可点击的，并且收到了down和up事件；<br>
	(11)事件传递过程是由外到内的，即事件总是先传给父元素，再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是DOWN事件除外；<br>
3.4.2 事件分发源码分析<br>
	1.Activity对点击事件的分发过程<br>
	   分析Activity的dispatchTouchEvent方法<br>
	   Activity会传给Window，如果返回false就意味着没人处理，Activity的onTouchEvent就会被调用.一般是Activity传给Window，Window再传给DecorView(DecorView就是setContentView设置的View的父容器)<br>
	    Window是个抽象类，对应的实现类是PhoneWindow，PhoneWindow会把事件传给DecorView，DecorView继承自FrameLayout。<br>
	2.顶级View(根View)对点击事件的分发过程<br>
	   顶级View也叫根View，一般是ViewGroup<br>
	   看ViewGroup的dispatchTouchEvent方法<br>
	   (1)onInterceptTouchEvent方法不是每次事件都会被调用；<br>
            (2)FLAG_DISALLOW_INTERCEPT可以解决滑动冲突的问题；<br>
	3.View对点击事件的分发过程<br>
	   单纯的View对点击事件的分发稍简单些，分析他的dispatchTouchEvent方法，如果onTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，所以onTouchListener的优先级高于onTouchEvent，好处是方便在外界处理点击事件。<br>
##3.5 View的滑动冲突
3.5.1 场景<br>
	(1) 外部滑动方向和内部滑动方向不一致<br>
	     ViewPager默认解决了滑动冲突，所以和ListView使用没问题，换做是ScrollView和ListView使用就有问题了<br>
	(2) 外部滑动方向和内部滑动方向一致<br>
	(3) (1)和(2)的嵌套<br>
3.5.2 处理规则<br>
	场景(1)=>根据滑动方向决定让那个View拦截事件<br>
	场景(2)和(3)=>需要根据业务决定<br>
3.5.3 解决方式<br>
	1.外部拦截法<br>
    	  重写父容器的onInterceptTouchEvent方法<br>
	2.内部拦截法<br>
	  需要配合requestDisallowInterceptTouchEvent方法<br>
