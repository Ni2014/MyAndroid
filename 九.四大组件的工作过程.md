#《Android开发艺术探索》读书笔记
#第九章 四大组件的工作过程
##9.1 四大组件的运行状态
	四大组件中除了BroadcastReceiver外，其他的三个都需要在AndroidManifest中注册，对于BroadcastReceiver，既可以在AndroidManifest中注册也可以在代码中注册，而在调用方式上，Activity，Service和BroadcastReceiver需要借助Intent，而ContentProvider则无须借助Intent。<br>
	(1)Activity是一种展示型组件，向用户展示一个界面并且可以接收用户的输入信息从而进行交互。其他三个对用户来说都是不可感知的。Activity的启动由Intent触发。<br>
	(2)Service是一种计算型组件，用于在后台执行一系列的计算任务，Activity组件只有一种运行模式，即Activity处于启动状态，但是Service组件有两种状态：启动和绑定状态，可以停止，灵活使用stopService和unBindService可以完全停止Service。<br>
	(3)BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用间传递消息。两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册广播，这种广播在应用安装时会被系统解析，这种形式的广播不需要应用启动就可以收到响应的广播。动态注册需要通过Context.registerReceiver()来实现，并且在不需要的时候通过Context.unRegisterReceiver()来解除广播，这种形式的广播必须要启动应用才能注册并接收广播，因为不启动应用就无法注册，就无法收到相应的广播。在开发中通过Context的一系列send方法来发送广播，被发送的广播会被系统发送给感兴趣的广播接收者，发送和接收的匹配是通过广播接收者的<intent-filter>来描述的，BroadcastReceiver可以来实现低耦合的观察者模式，观察者和被观察者之间可以没有任何耦合，不适合用来执行耗时操作，一般不需要停止，也没有挺值的概念。<br>
	(4)ContentProvider是一种数据共享型的组件，用于向其他组件乃至其他应用共享数据，内部要实现CRUD操作，在它的内部维持着一份数据集合，这个数据集合既可以通过数据库来实现，也可以通过其他数据类型来实现，比如List和Map，需要注意的是ContentProvider内部的insert，delete，update和query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。<br>
##9.2 Activity的工作过程
	系统内部是如何启动一个Activity的呢？Activity对象是如何被new出来的呢，Activity的onCreate方法是何时被系统回调的呢？<br>
	(1)分析Activity的启动过程从Activity的startActivity方法开始，他有好几种重载方式，但最终都会调用startActivityForResult方法。<br>
	ActivityGroup最开始被用来在一个界面中嵌入多个子Activity，在Api13已经被弃用，系统推荐用Fragment代替ActivityGroup；<br>
	ApplicationThread是ActivityThread的一个内部类。<br>
	(2)再看Instrumentation的execStart‘Activity方法，启动Activity的真正实现由ActivityManagerNative.getDefault()的startActivity方法完成。ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，所以AMS也是一个Binder，是IActivityManager的具体实现。因为ActivityManagerNative.getDefault()其实是一个IActivityManager类型的Binder对象，所以它的具体实现是AMS。<br>
	所以现在Activity的启动过程就转移到了AMS中，查看AMS的startActivity方法。<br>
##9.3 Service的工作过程
	Service的两种状态：①启动状态一般用于执行后台计算；②绑定状态一般用于其他组件和Service的交互。注意这两种状态是可以共存的，通过Context的startService即可启动一个Service，通过Context的bindService方法即可以绑定的方式启动一个Service；<br>
9.3.1 Service的启动过程<br>
	从ContextWrapper的startService开始
##9.4 BroadcastReceiver的工作过程
##9.5 ContentProvider的工作过程
