#《Android开发艺术探索》读书笔记
#第十章 Android的消息机制
##10.1 概述
	
(1)Android的消息机制主要是指Handler的运行机制以及Handler所附带的MessageQueue和Looper的工作过程，为什么Android会提供Handler呢?==>Android中规定访问UI只能在主线程中进行，ViewRootImpl对UI操作做了验证，这个验证工作是由于ViewRootImpl的checkThread方法完成的，导致必须在主线程中去访问UI，但是耗时操作如果在UI线程中进行就会有ANR，系统提供Handler，就是为了解决在子线程中无法访问UI的矛盾。<br>
	既然Android中的主线程的不安全的，那么为什么不加上锁呢？①锁机制会让UI访问的逻辑变得复杂；②锁机制会降低UI访问的效率(锁机制会阻塞某个线程的执行)；<br>
	(2)Handler的工作原理：Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程中没有Looper就会报错；<br>
	Handler创建后，内部的Looper和MessageQueue就可以和Handler一起协同工作了。<br>
	通过Handler的post方法将一个Runnable投递到Handler内部的Looper中去处理，也可以通过Handler的send方法发送一个消息，其实post方法最终也是调用send方法完成的；<br>
	send方法的工作过程，当Handler的send方法被调用时，它会调用MessageQueue的enqueueMessage方法将这个消息放入消息队列中，然后Looper发现有新的消息到来时，就会处理这个消息，最终消息中的Runnable或Handler的handleMessage方法会被调用。注意Looper是运行在创建Handler所在的线程中的，这样的话Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。<br>
##10.2 分析
10.2.1 ThreadLocal的工作原理<br>
	
ThreadLocal是一个线程内部的数据存储类，通过他可以在指定的先线程中存储数据
10.2.2 消息队列的工作原理<br>
	
MessageQueue主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别是enqueueMessage和next，enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从队列中移除。虽然MessageQueue叫做队列，但是其内部实现却不是队列，是通过单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。看下enqueueMessage和next方法的实现。<br>
	next方法中有个代码段`for(;;)`,是个无限循环的方法，如果消息队列中没有消息，那么next方法就会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将其从单链表中移除(读取并移除)。<br>
10.2.3 Looper的工作原理<br>
	
Looper做了什么呢？具体来说就是不停从MessageQueue中查看是否有新的消息，有新的消息就立刻处理，否则就一直阻塞在那里。在它的构造方法中，会创建一个MessageQueue，并将当前线程的对象保存起来。<br>
	
怎么创建一个Looper呢，通过Looper.prepare()就创建了一个当前线程的Looper，接着再通过Looper.loop()来开启消息循环；<br>
	Looper除了prepare方法外还有prepareMainLooper方法，这个方法主要是给主线程也就是ActivityThread创建Looper用的，本质也是通过prepare方法实现的。因为主线程的Looper比较特殊，所以Looper提供了getMainLooper方法，通过他可以在任何地方取到主线程的Looper。<br>
	Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别是：quit会直接退出Looper，而quitSafely只是设定一个退出标记，再把消息队列中的已有消息处理完毕后才安全退出的。<br>
	Looper退出后，通过Handler发送消息会失败，这时Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成后应该调用quit方法来终止消息循环，否则这个子线程就会一直处在等待的状态，如果退出了Looper后，这个线程就立刻终止，所以建议在不需要的时候退出Looper。<br>
	Looper最重要的方法是loop方法，只有调用了loop方法后，消息循环系统才会真正地起作用；<br>
	loop方法是个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null。<br>
10.2.4 Handler的工作原理<br>
	
Handler的工作主要包含消息的发送和接收过程；<br>
	消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post最终还是调了send方法；<br>
	Handler发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就进入了处理消息的阶段。注意dispatchMessage的实现；<br>
##10.3 主线程的消息循环
	
(1)Android中的主线程就是ActivityThread，主线程的入口方法是main()，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()来开启主线程的消息循环。
	(2)主线程的消息循环开始了以后，ActivityThread还需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程；<br>
	(3)ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。<br>	
